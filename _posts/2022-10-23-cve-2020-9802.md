---
layout: post
title: "Exploitation of CVE-2020-9802: JSC's JIT Incorrect Common Subexpression Elimination for ArithNegate"
date: 2022-09-23
permalink: /:title/
description: "Exploitation of an out of bound bug in Common Subexpression Elimination optimizations"
tags: [safari, n-day]
share: true
comments: false
published: false
---

---
* toc
{:toc}
---

## Introduction

Speculative compilers are designed to produce the most efficient code possible
for a dynamic language. The core idea is to leverage the decades of
optimization research done on traditional compilers. New challenges arise with
dynamic languages because they lack type information that would otherwise make
it very easy to understand and optimize code. JavaScriptCore's speculative
compilation is made of several optimising compilers stacking on top of each
other, each one optimizing according to execution trends observed by the
preceding one. The layered architecture also makes it easy to balance the
latency/throughput tradeoff and to fine tune optimization on a per-function
basis. For instance, it would be wasteful to aggressively optimize a short
function a few times executed as it would be to interpret a hot function.

JIT bugs are some of the most complex ones that can be found in a modern
browser due to the inherent complexity of the affected component. They can be
difficult to find via fuzzing and are likely to live longer.  
Despite not being beginner friendly, they are a great occasion to learn about
compilers, optimization and Intermediate Rappresentations (IRs).

Saelo from Google Project Zero disclosed a vulnerability in WebKit's JavaScript
engine JavaScriptCore's DFG (Data Flow Graph) JIT compiler: a powerful and somewhat
esoteric bug that can be leveraged to obtain an out of bound memory access.
One of the optimization passes done by DFG, substitutes expressions incorrectly
and confuses integers that are supposed to overflow with those who do not.

This blog post covers speculative execution, JavaScriptCore, JIT engine
exploitation techniques.

## Preexisting knowledge

To learn more about speculation in JavaScriptCore the reader is advised to read
[Filip Pizlo (@filipizlo)](https://twitter.com/filipzilo)'s
[article](https://webkit.org/blog/10308/speculation-in-javascriptcore/) on
published on WebKit official website.
Moreover, Zon8 did a fantastic low level analysis of the implementation of the
optimising compilers.

## Environment Setup

This was by far the most painful part as after being stuck for days on weird
compilations errors, I was told by a maintainer of WebKit
[Sam(@snedder)](twitter.com/snedder) that I didn't have the correct version of
Xcode and macOS installed to compile JavaScriptCore.I therefore decided to work
on a Ubuntu machine as I didn't have a device to test PAC on.

Shallow cloning allows to saves some space as a large chunk of history is
truncated.

```
git clone --shallow-since="2020-03-01" git@github.com:WebKit/WebKit.git
```

In order to find the last vulnerable commit I made use of git's search feature
looking for CSE changes to ArithNegate and checking out the parent commit

```
git checkout aed886669bd4ec3bd21ce769c3459300bada7c83^
```

## Introduction to Common-Subexpression Elimination

> In compiler theory, common subexpression elimination (CSE) is a compiler
> optimization that searches for instances of identical expressions (i.e., they
> all evaluate to the same value), and analyzes whether it is
> worthwhile replacing them with a single variable holding the computed value.  
> ~ Wikipedia

Let's consider the following example

```javascript
let x = y * y + y * y
```
Performing the multiplication twice might be a inefficient, therefore it would
be optimized as such:

```javascript
let z = y * y
let x = z + z
```

This might be more efficient as `y * y` is performed only once and the value is
loaded from a register. The profiler, the component that understands and
creates an _execution profile_ for code executed frequently, keeps into account
whether it is more expensive to access memory for a value or perform the
calculation multiple times. For instance, using CSE too aggressively puts
strain onto registers, which are finite in number, which may in turn cause
values to slip onto memory causing a slowdown due to frequent memory accesses.

## Common-Subexpression Elimination in JavaScriptCore

> In software engineering and computer science, clobbering a file, processor
> register or a region of computer memory is the process of overwriting its
> contents completely, whether intentionally or unintentionally, or to indicate
> that such an action will likely occur. ~ Wikipedia

JavaScriptCore uses a clobberizer to decide which nodes are eligible for CSE.
File `Source/JavaScriptCore/dfg/DFGClobberize.h` defines how nodes are
clobberized.

```cpp
...
switch (node->op()) {
case JSConstant:
case DoubleConstant:
case Int52Constant:
    def(PureValue(node, node->constant()));
    return;
...
```
If a given node in the DFG IR is of type `Int52Constant` the clobberizer uses
the `def()` functor to evaluate whether the node is CSEable. `def()` return
locations and they have to adhere to two rules:

1. Every path between the two nodes to be clobberized does not perform any
   write to any heap location that overlaps the desired location. To put it
   simply, if no writes are performed on a heap location defined by a node two
   things happen:
    - the two nodes satisfy condition `1`
    - the value of said location can be deduced by looking at one of the nodes

2. If a load operation is to be CSE'd, the `HeapLocation` object is
   sufficient to find the second eligible node

`PureValue` means that the result of a computation will always be the same for
a given input, in the same way in which a function is defined in mathematics
(or a pure function in computer science).

## Bug analysis 

The bug is in the `ArithNegate` case, the one used to handle the rapresentation
arithmetical negation of a number. The problem is that `def()`
does not take into account whether the number is speculated to potentially
overflow or not, thus causing incorrect substitutions between the two.

```cpp
...
case ArithNegate:
if (node->child1().useKind() == Int32Use
    || node->child1().useKind() == DoubleRepUse
    || node->child1().useKind() == Int52RepUse)
    def(PureValue(node));                    // incorrect
    // def(PureValue(node, node->arithMode())); correct
else {
...
```

Numbers that are speculated to overflow are represented as CheckedInt32: they
are runtime guarded to bailout optimized code when an overflow is detected.

Let's take 32 bit integers as an example: `INT_MIN` is the lowest 32 bit signed
integer and is equal to `-2147483648` which in binary is
`10000000000000000000000000000000b`. Negating `INT_MIN` performes 2's
complement:

```
10000000000000000000000000000000
01111111111111111111111111111111
                              +1
---------------------------------
10000000000000000000000000000000
```

_Note: the number discussed is signed, therefore an overflow occures when bit
31st MSB is set, not the 32th_  

A JavaScript user would normally expect that `-2147483648` negated becomes
`2147483648`. An engine would normally bailout if it detects that the
program executed overflowed trying to rappresent a number out of range. 
Negating `INT_MIN` yields a number greater than `INT_MAX` `(2147483647)` and
could potentially go undetected if CSE confuses `Checked32Int` and `Unchecked32Int`

## Triggering the bug

Lets dump DFG's IR to observe CSE in action. `--options` dumps all tuning parameters

```
thresholdForJITAfterWarmUp=500
thresholdForJITSoon=100
thresholdForOptimizeAfterWarmUp=1000
thresholdForOptimizeAfterLongWarmUp=1000
thresholdForOptimizeSoon=1000
useFTLJIT=true
verboseCompilation=false
dumpDFGGraphAtEachPhase=false
dumpDFGFTLGraphAtEachPhase=false
dumpDFGDisassembly=false
```

```
f#EP7qzd:[0x7f4fb4dc8130->0x7f4fb4de5200, NoneFunctionCall, 46]: 13 instructions (0 16-bit instructions, 0 32-bit instructions, 6 instructions with metadata); 158 bytes (112 metadata bytes); 2 parameter(s); 10 callee register(s); 6 variable(s); scope at loc4
[   0] enter
[   1] get_scope          loc4
[   3] mov                loc5, loc4
[   6] check_traps
[   7] mov                loc6, <JSValue()>(const0)
[  10] mov                loc7, <JSValue()>(const0)
[  13] bitor              arg1, arg1, Int32: 0(const1)
[  18] negate             loc8, arg1, 126
[  23] bitor              loc6, loc8, Int32: 65535(const2)
[  28] negate             loc8, arg1, 126
[  33] negate             loc9, arg1, 126
[  38] mul                loc7, loc8, loc9, OperandTypes(10, 10)
[  44] ret                Undefined(const3)

Constants:
   k0 = <JSValue()>
   k1 = Int32: 0: in source as integer
   k2 = Int32: 65535: in source as integer
   k3 = Undefined

End: undefined
root@localhost:~/research/WebKit# head ../pocs/negate.js
function f(n) {
	// JavaScript type Number is float by default, a bitwise or converts n
	// from `float` to `double`
	n |= 0;

	let _unused = (-n) | 0xffff;

	// optimize the multiplication into ArithPow during DFGFixUp phase
	let q = (-n) * (-n);
}
```


Unfortunately providing two consecuting negations does not equate to two
`ArithNegate` nodes because the numbers are converted to float first, which are
not subject to overflows.

## Full exploit code

The full exploit can be found at []().

## References

- [Saelo's bug disclosure](https://bugs.chromium.org/p/project-zero/issues/detail?id=1685&desc=2)
- [Zon8 JavaScriptCore compilation internals](https://bugs.chromium.org/p/project-zero/issues/detail?id=1685&desc=2)
- [Saelo's Attacking JavaScript Egines](http://www.phrack.org/issues/70/3.html#article)
