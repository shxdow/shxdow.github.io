---
layout: post
title: "Exploiting CVE-2020-9802: JSC's JIT Incorrect Common Subexpression Elimination for ArithNegate"
date: 2022-09-23
permalink: /:title/
description: "Exploitation of an out of bound bug in Common Subexpression Elimination optimizations"
tags: [safari, n-day]
share: true
comments: false
published: true
status: ongoing
---

---
* toc
{:toc}
---

saelo from Google Project Zero disclosed a vulnerability in WebKit's
JavaScript engine JavaScriptCore's (jsc) JIT compiler: a powerful bug that can
be leveraged to obtain an out of bound memory access.


## Finding the commit

In order to find the vulnerable commit I made use of git's feature that allows
to checkout a commit at a specific date:

```
git checkout 'main@{2020-03-05 00:00:00}'
```

The bug was reported on Friday, March 6 of 2020 at 4:00 AM GMT+1, therefore I
chose to checkout at a commit of the day before.


```
mba :: git/webkit » v Source/JavaScriptCore/runtime/JSArray.cpp
mba :: git/webkit » git log -L :shiftCountWithArrayStorage:Source/JavaScriptCore/runtime/JSArray.cpp
mba :: git/webkit » git show 670be5649c52c3d07db849f4509e4f34da29b837^
mba :: git/webkit » git checkout 9d35c057957d90746e4f0166c68ba466c25a64f5
```

## Preliminary details


```
commit 670be5649c52c3d07db849f4509e4f34da29b837
Author: Saam Barati <sbarati@apple.com>
Date:   Mon Oct 15 19:14:42 2018 +0000

    JSArray::shiftCountWithArrayStorage is wrong when an array has holes
    https://bugs.webkit.org/show_bug.cgi?id=190262
    <rdar://problem/44986241>

    Reviewed by Mark Lam.

    JSTests:

    * stress/array-prototype-concat-of-long-spliced-arrays.js:
    (test):
    * stress/slice-array-storage-with-holes.js: Added.
    (main):

    Source/JavaScriptCore:

    We would take the fast path for shiftCountWithArrayStorage when the array
    hasHoles(). However, the code for this was wrong. It'd incorrectly update
    ArrayStorage::m_numValuesInVector. Since the hasHoles() for ArrayStorage
    path is never taken in JetStream 2, this patch just removes that from
    the fast path. Instead, we just fallback to the slow path when hasHoles().
    If we find evidence that this matters for real use cases, we can
    figure out a way to make the fast path work.

    * runtime/JSArray.cpp:
    (JSC::JSArray::shiftCountWithArrayStorage):



    Canonical link: https://commits.webkit.org/205503@main
    git-svn-id: https://svn.webkit.org/repository/webkit/trunk@237129 268f45cc-cd09-0410-ab3c-d52691b4dbfc

diff --git a/Source/JavaScriptCore/runtime/JSArray.cpp b/Source/JavaScriptCore/runtime/JSArray.cpp
--- a/Source/JavaScriptCore/runtime/JSArray.cpp
+++ b/Source/JavaScriptCore/runtime/JSArray.cpp
@@ -799,108 +799,83 @@
 bool JSArray::shiftCountWithArrayStorage(VM& vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
 {
     unsigned oldLength = storage->length();
     RELEASE_ASSERT(count <= oldLength);

     // If the array contains holes or is otherwise in an abnormal state,
     // use the generic algorithm in ArrayPrototype.
-    if ((storage->hasHoles() && this->structure(vm)->holesMustForwardToPrototype(vm, this))
+    if (storage->hasHoles()
         || hasSparseMap()
         || shouldUseSlowPut(indexingType())) {
         return false;
     }

     if (!oldLength)
         return true;

     unsigned length = oldLength - count;

     storage->m_numValuesInVector -= count;
     storage->setLength(length);

     unsigned vectorLength = storage->vectorLength();
     if (!vectorLength)
         return true;

     if (startIndex >= vectorLength)
         return true;

     DisallowGC disallowGC;
     auto locker = holdLock(cellLock());

     if (startIndex + count > vectorLength)
         count = vectorLength - startIndex;

     unsigned usedVectorLength = std::min(vectorLength, oldLength);

     unsigned numElementsBeforeShiftRegion = startIndex;
     unsigned firstIndexAfterShiftRegion = startIndex + count;
     unsigned numElementsAfterShiftRegion = usedVectorLength - firstIndexAfterShiftRegion;
     ASSERT(numElementsBeforeShiftRegion + count + numElementsAfterShiftRegion == usedVectorLength);

     // The point of this comparison seems to be to minimize the amount of elements that have to
     // be moved during a shift operation.
     if (numElementsBeforeShiftRegion < numElementsAfterShiftRegion) {
         // The number of elements before the shift region is less than the number of elements
         // after the shift region, so we move the elements before to the right.
         if (numElementsBeforeShiftRegion) {
             RELEASE_ASSERT(count + startIndex <= vectorLength);
-            if (storage->hasHoles()) {
-                for (unsigned i = startIndex; i-- > 0;) {
-                    unsigned destinationIndex = count + i;
-                    JSValue source = storage->m_vector[i].get();
-                    JSValue dest = storage->m_vector[destinationIndex].get();
-                    // Any time we overwrite a hole we know we overcounted the number of values we removed
-                    // when we subtracted count from m_numValuesInVector above.
-                    if (!dest && destinationIndex >= firstIndexAfterShiftRegion)
-                        storage->m_numValuesInVector++;
-                    storage->m_vector[count + i].setWithoutWriteBarrier(source);
-                }
-            } else {
-                memmove(storage->m_vector + count,
-                    storage->m_vector,
-                    sizeof(JSValue) * startIndex);
-            }
+            memmove(storage->m_vector + count,
+                storage->m_vector,
+                sizeof(JSValue) * startIndex);
         }
         // Adjust the Butterfly and the index bias. We only need to do this here because we're changing
         // the start of the Butterfly, which needs to point at the first indexed property in the used
         // portion of the vector.
         Butterfly* butterfly = this->butterfly()->shift(structure(vm), count);
         storage = butterfly->arrayStorage();
         storage->m_indexBias += count;

         // Since we're consuming part of the vector by moving its beginning to the left,
         // we need to modify the vector length appropriately.
         storage->setVectorLength(vectorLength - count);
         setButterfly(vm, butterfly);
     } else {
         // The number of elements before the shift region is greater than or equal to the number
         // of elements after the shift region, so we move the elements after the shift region to the left.
-        if (storage->hasHoles()) {
-            for (unsigned i = 0; i < numElementsAfterShiftRegion; ++i) {
-                unsigned destinationIndex = startIndex + i;
-                JSValue source = storage->m_vector[firstIndexAfterShiftRegion + i].get();
-                JSValue dest = storage->m_vector[destinationIndex].get();
-                // Any time we overwrite a hole we know we overcounted the number of values we removed
-                // when we subtracted count from m_numValuesInVector above.
-                if (!dest && destinationIndex < firstIndexAfterShiftRegion)
-                    storage->m_numValuesInVector++;
-                storage->m_vector[startIndex + i].setWithoutWriteBarrier(source);
-            }
-        } else {
-            memmove(storage->m_vector + startIndex,
-                storage->m_vector + firstIndexAfterShiftRegion,
-                sizeof(JSValue) * numElementsAfterShiftRegion);
-        }
+        memmove(storage->m_vector + startIndex,
+            storage->m_vector + firstIndexAfterShiftRegion,
+            sizeof(JSValue) * numElementsAfterShiftRegion);
+
         // Clear the slots of the elements we just moved.
         unsigned startOfEmptyVectorTail = usedVectorLength - count;
         for (unsigned i = startOfEmptyVectorTail; i < usedVectorLength; ++i)
             storage->m_vector[i].clear();
         // We don't modify the index bias or the Butterfly pointer in this case because we're not changing
         // the start of the Butterfly, which needs to point at the first indexed property in the used
         // portion of the vector. We also don't modify the vector length because we're not actually changing
         // its length; we're just using less of it.
     }

     return true;
 }

         storage->setVectorLength(vectorLength - count);
         setButterfly(vm, butterfly);
     } else {
         // The number of elements before the shift region is greater than or equal to the number
         // of elements after the shift region, so we move the elements after the shift region to the left.
-        if (storage->hasHoles()) {
-            for (unsigned i = 0; i < numElementsAfterShiftRegion; ++i) {
-                unsigned destinationIndex = startIndex + i;
-                JSValue source = storage->m_vector[firstIndexAfterShiftRegion + i].get();
-                JSValue dest = storage->m_vector[destinationIndex].get();
-                // Any time we overwrite a hole we know we overcounted the number of values we removed
-                // when we subtracted count from m_numValuesInVector above.
-                if (!dest && destinationIndex < firstIndexAfterShiftRegion)
-                    storage->m_numValuesInVector++;
-                storage->m_vector[startIndex + i].setWithoutWriteBarrier(source);
-            }
-        } else {
-            memmove(storage->m_vector + startIndex,
-                storage->m_vector + firstIndexAfterShiftRegion,
-                sizeof(JSValue) * numElementsAfterShiftRegion);
-        }
+        memmove(storage->m_vector + startIndex,
+            storage->m_vector + firstIndexAfterShiftRegion,
+            sizeof(JSValue) * numElementsAfterShiftRegion);
+
         // Clear the slots of the elements we just moved.
         unsigned startOfEmptyVectorTail = usedVectorLength - count;
         for (unsigned i = startOfEmptyVectorTail; i < usedVectorLength; ++i)
             storage->m_vector[i].clear();
         // We don't modify the index bias or the Butterfly pointer in this case because we're not changing
         // the start of the Butterfly, which needs to point at the first indexed property in the used
         // portion of the vector. We also don't modify the vector length because we're not actually changing
         // its length; we're just using less of it.
     }

     return true;
 }
```


## Bug analysis 

Running the proof of concept did not cause a crash.


## Full exploit code


The full exploit can be found at []().

## References

- [Saelo's Attacking JavaScript Egines](http://www.phrack.org/issues/70/3.html#article)
- [lokihardt from Google Project Zero](https://bugs.chromium.org/p/project-zero/issues/detail?id=1685&desc=2)
- [Romanian Security Team Forums](https://rstforums.com/forum/topic/110439-cve-2018-4441-oob-rw-via-jsarrayunshiftcountwitharraystorage-webkit/)
- [Devilx86's attempt in porting the bug on the Nintendo Switch](https://devilx86.github.io/writeups/CVE-2018-4441/)
